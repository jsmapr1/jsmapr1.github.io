<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		
		<meta name="generator" content="Hugo 0.37.1" />
		<title>Testing Redux Combined Reducers &middot; dev</title>
		<link rel="shortcut icon" href="http://thejoemorgan.com/images/favicon.ico">
		<link rel="stylesheet" href="http://thejoemorgan.com/css/style.css">
		<link rel="stylesheet" href="http://thejoemorgan.com/css/highlight.css">

		
		<link rel="stylesheet" href="http://thejoemorgan.com/css/monosocialiconsfont.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='http://thejoemorgan.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='http://thejoemorgan.com/posts'>Archive</a>
	<a href='http://thejoemorgan.com/tags'>Tags</a>
	<a href='http://thejoemorgan.com/about'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        Testing Redux Combined Reducers
                    </h1>
                    <h2 class="headline">
                    Mar 25, 2016 14:52
                    · 644 words
                    · 4 minute read
                      <span class="tags">
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>I have a few problems recently testing Redux reducers.
The <a href="http://redux.js.org/docs/recipes/WritingTests.html">documentation</a> is helpful but doesn&rsquo;t match the rest of the tutorial.</p>

<h2 id="simple-test">Simple Test</h2>

<p>Consider a basic reducer:</p>

<pre><code class="language-javascript">export function tagFilter(state = [], action) {
  switch(action.type) {
    case 'TAG_FILTER':
      return [...state, action.tag]
    default:
      return state;
  }
}

</code></pre>

<p>The test for this is very simple. Call the function. Pass a state and an action. Expect the result:</p>

<pre><code class="language-javascript">import expect from 'expect';
import {tagFilter} from '../../js/redux/reducers';

describe('reducer tests', () =&gt; {
  it('should handle tagFilter', () =&gt; {
    const tag = 'foo';
    expect(
        tagFilter([], {
          type: 'TAG_FILTER',
          tag
        })
    ).toEqual(
      [tag]
    )

    expect(
      tagFilter(['bar'], {
          type:'TAG_FILTER',
          tag
        }
      )
    ).toEqual(
          ['bar', tag]
    )
  })
})
</code></pre>

<p>This is all very simple and explained in the official documentation.</p>

<p>The problem is that this test does not conform to the rest of the documentation.</p>

<h2 id="larger-test">Larger Test</h2>

<p>The documentation spends a lot of time talking about <a href="http://redux.js.org/docs/basics/Reducers.html#splitting-reducers">splitting reducers</a> and then combining them into a single reducer.</p>

<p>We now have a test for each split reducer, but we do not have a way to test the combined reducer. In a way, this is better cause it keeps are tests minimal and isolated, but looking at how we can test a combined reducer will help us to better understand the state object.</p>

<p>Here&rsquo;s a slightly larger set of reducers:</p>

<pre><code class="language-javascript">import { combineReducers } from 'redux';

export function tagFilter(state = [], action) {
  switch(action.type) {
    case 'TAG_FILTER':
      return [...state, action.tag]
    default:
      return state;
  }
}

export function savedItems(state = [], action) {
  switch(action.type) {
    case 'SAVE_ITEM':
      return [...state, action.id]
    case 'REMOVE_ITEM':
        return [
          ...state.slice(0,state.indexOf(action.id)),
          ...state.slice(state.indexOf(action.id)+1)
        ]
    default:
        return state;
  }
}

export const app = combineReducers({
  tagFilter,
  savedItems
})
</code></pre>

<p>Notice that I am exporting each individual reducer as well as the combined reducer.</p>

<p>If I wanted to test individual reducers, I would proceed as above. If I wanted to test a reducer in the context of a combined reducer,
I would need to slightly change my expectations.</p>

<p>The combined reducer returns an object that consists of the name of the reducer and the state. So my combined reducer would return this:</p>

<pre><code class="language-javascript">  {
    tagFilter: [],
    savedItems: []
  }
</code></pre>

<p>If I wanted to test the <code>tagFilter</code>, my expect would either have to account for the base and update the object or it would have to pull the correct state from the combined reducer. Here is an example of the first:</p>

<pre><code class="language-javascript">import expect from 'expect';
import {tagFilter, savedItems, app} from '../../js/redux/reducer';
import * as actions from '../../js/redux/actions';

describe('reducer tests', () =&gt; {
  const base = {
    tagFilter: [],
    savedItems: []
  }
  it('should handle tagFilter', () =&gt; {
    const tag = 'foo';
    expect(
        app([], {
          type: 'TAG_FILTER',
          tag
        })
    ).toEqual(
      Object.assign(
        base,
        {
          'tagFilter': [tag]
        }
      )
    )

    expect(
      app(
        Object.assign(
          base,
          {
            'tagFilter': ['bar']
          }
        ), {
          type:'TAG_FILTER',
          tag
        }
      )
    ).toEqual(
      Object.assign(
        base,
        {
          'tagFilter': ['bar', tag]
        }
      )
    )
  })
})
</code></pre>

<p>And here is an example of the second:</p>

<pre><code class="language-javascript">import expect from 'expect';
import {app} from '../../js/redux/reducer';
import * as actions from '../../js/redux/actions';

describe('reducer tests', () =&gt; {
  it('should handle tagFilter', () =&gt; {
    const tag = 'foo';
    const base = {
      tagFilter: [],
      savedItems: []
    }

    expect(
        app([], {
          type: 'TAG_FILTER',
          tag
        }).tagFilter
    ).toEqual(
      [tag]
    )

    expect(
      app(
        Object.assign(
          base,
          {
            'tagFilter': ['bar']
          }
        ), {
          type:'TAG_FILTER',
          tag
        }
      ).tagFilter
    ).toEqual(
        ['bar', tag]
    )
  })
})
</code></pre>

<p>Notice how I still need to include the base object in the second part of the test so that I can set an initial state.
It&rsquo;s not strictly necessary for the first part of the test where we are starting with an empty state, but it is necessary for the second part where we are appending state.</p>

<p>Testing <code>savedItems</code> is roughly the same idea.
It&rsquo;s probably best to keep tests minimal and to test each reducer in isolation from the combined reducer, however, that is not the only approach.</p>

                </section>
            </article>

            

            

            

            <footer id="footer">
    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> 
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="http://thejoemorgan.com/js/jquery-3.3.1.min.js"></script>
<script src="http://thejoemorgan.com/js/main.js"></script>
<script src="http://thejoemorgan.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
