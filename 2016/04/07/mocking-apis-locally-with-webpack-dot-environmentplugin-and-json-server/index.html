<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		
		<meta name="generator" content="Hugo 0.34" />
		<title>Mocking Apis Locally with webpack and json-server &middot; </title>
		<link rel="shortcut icon" href="http://thejoemorgan.comimages/favicon.ico">
		<link rel="stylesheet" href="http://thejoemorgan.comcss/style.css">
		<link rel="stylesheet" href="http://thejoemorgan.comcss/highlight.css">

		
		<link rel="stylesheet" href="http://thejoemorgan.comcss/monosocialiconsfont.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='http://thejoemorgan.com'> <span class="arrow">←</span>Home</a>
	
	<a href='http://thejoemorgan.composts'>Archive</a>
	<a href='http://thejoemorgan.comtags'>Tags</a>
	<a href='http://thejoemorgan.comabout'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        Mocking Apis Locally with webpack and json-server
                    </h1>
                    <h2 class="headline">
                    Apr 7, 2016 16:00
                    · 980 words
                    · 5 minute read
                      <span class="tags">
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>I always love the beginning of a new project.
It&rsquo;s a great time to rethink a few basic fundamentals and to improve the overall development experience.</p>

<p>On my most recent project, I decided to give webpack a try.
I&rsquo;ve thought about using webpack before, but never pulled the trigger until one blogger deemed it the &lsquo;winner&rsquo; of <a href="https://medium.com/javascript-and-opinions/state-of-the-art-javascript-in-2016-ab67fc68eb0b#.qv9ei0f00">dependency management</a>
I decided. Why not. Let&rsquo;s give it a go.</p>

<p>I&rsquo;m not fully converted quite yet, but I did run into an interesting use case today.
I&rsquo;m building a single page app that will serve as an events page for a week long event. It will be similar to a conference page.</p>

<p>I&rsquo;ll be pulling in a list of events from an api on the base site and then I&rsquo;ll handle filtering, saving, sharing, and all that fun stuff with React.</p>

<p>So far, so normal. The trick is that the api will ultimately be on the same domain as the single page app, but for development purposes, I&rsquo;m keeping them separate (mostly so the full app can be in a separate git repo, but other reasons as well).
Now I have a problem dealing with <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">cross-origin resource sharing</a>.
The code I&rsquo;m working on is on localhost and the api is on the test site for the original site (for purposes of this post, we&rsquo;ll call it foo.app).</p>

<p>I thought about just modifying the headers on foo.app locally, but I want to allow other devs to contribute and everyone has slightly different development set ups (a problem for another day).
Out the window goes that idea.</p>

<p>The problem came to this: How can I make an api server that I can include with the project? And how can I configure the project to use that during development and the actual server in production?</p>

<h2 id="a-simple-local-server">A simple local server</h2>

<p>The answer to the api server was ridiculously simple thanks to a great project called <a href="https://github.com/typicode/json-server">json-server</a>.</p>

<p>The project is hosted on npm, so a simple install pulled it into my codebase <code>npm install --save-dev json-server</code>.
The official documentation suggests installing it globally, but I wasn&rsquo;t interested in that. I wanted the project to be dead simple for other developers to jump into, so I added a simple start up script to my package.json.
Make note of the start script, we&rsquo;ll come back to that in a bit.</p>

<pre><code class="language-javascript">  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --output-public-path=/public/&quot;,
    &quot;api&quot;: &quot;json-server --watch db.json --port 3004&quot;
  }
</code></pre>

<p>After the project is cloned and dependencies installed, future devs just have to run <code>npm run api</code> to get the api server up and running.</p>

<p>The second step is to create a db.json file to serve as the mock data.
My api endpoint will be <strong>foo.app/foo-fest</strong> and I want an array of events, so the db.json file will looks something like this:</p>

<pre><code class="language-javascript">{
    &quot;foo-fest&quot;: {
       &quot;events&quot;: [
            {
                &quot;title&quot;: &quot;Cool Title&quot;,
                &quot;description&quot;: &quot;So Cool&quot;,
                &quot;event&quot;: &quot;Saturday, April 9, 2016, 12 - 1pm&quot;,
                &quot;tags&quot;: &quot;cool&quot;
            },
            {
                &quot;title&quot;: &quot;Awesom Title&quot;,
                &quot;description&quot;: &quot;So Awesome&quot;,
                &quot;event&quot;: &quot;Sunday, April 10, 2016, 12 - 1pm&quot;,
                &quot;tags&quot;: &quot;awesome&quot;
            }
        ]
    }
}
</code></pre>

<p>At this point, with the server running, a visit to <strong>localhost:3004/foo-fest</strong> will return an object containing &ldquo;events&rdquo; and the array.</p>

<p>Phase one, check.</p>

<h2 id="configure-api-url-by-environment">Configure API url by environment</h2>

<p>With phase one under control, the next step is to query the correct api depending on the environment. This is where webpack enters the picture.</p>

<p>I wanted to be able to use the build in webpack server for development, but needed to pass the environment variable.</p>

<p>Previously, the suggestions was to use <a href="https://twitter.com/dan_abramov/status/592692202335301636">DefinePlugin</a> to set the NODE_ENV.
However, that lead to some rather <a href="http://stackoverflow.com/a/31517695">clunky code</a> to allow different variables to be passed.</p>

<p>Fortunately, as was noted later in the Stack Overflow post, webpack introduced a new way to define environment variables called
<a href="https://github.com/webpack/docs/wiki/list-of-plugins#environmentplugin">EnvironmentPlugin</a>.
There are some security benefits, but the main advantage was it cleans everything up.</p>

<p>Here&rsquo;s my webpack.config with an EnvironmentVariable:</p>

<pre><code class="language-javascript">    plugins: [
      new webpack.EnvironmentPlugin([
          'NODE_ENV'
      ])
    ],
</code></pre>

<p>With this in place, I can pass the NODE_ENV variable through webpack and into the application.</p>

<p>The next step is to add an config that holds the url for the api by environment.
The config is very basic. I may use it in the future. I may not. For now here, it is:</p>

<pre><code class="language-javascript">export default {
    &quot;production&quot;: {
        &quot;api&quot; : &quot;http://foo.app&quot;
    },
    &quot;dev&quot;: {
        &quot;api&quot;: &quot;http://localhost:3004&quot;
    }
}
</code></pre>

<p>I&rsquo;m use redux to handle state and dispatching of actions. So, I&rsquo;ve modified my fetch method to accept a url:</p>

<pre><code class="language-javascript">export const fetchEvents = (url) =&gt; {
  return (dispatch) =&gt; {
    return fetch(url, {})
        .then(response =&gt; {
            return response.json()
        })
        .then(json =&gt; {
          dispatch(receiveEvents(json));
        })
        .catch(err =&gt; console.log(err))
  }
}
</code></pre>

<p>In my application code, I choose the correct url using the environment variable.
Then I pass it to my dispatch method:</p>

<pre><code class="language-javascript">
import configureStore from './redux/configureStore';
import config from './config';
const url = config[process.env.NODE_ENV].api + '/foo-fest';
let store = configureStore();
store.dispatch(fetchEvents(url));
</code></pre>

<p>Finally, I update my package.json to run the webpack server with dev as the environment:</p>

<pre><code class="language-javascript">  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;NODE_ENV=dev webpack-dev-server --output-public-path=/public/&quot;,
    &quot;api&quot;: &quot;json-server --watch db.json --port 3004&quot;
  }
</code></pre>

<h2 id="wrapping-up">Wrapping Up</h2>

<p>At this point, future developers can just clone the repo and run a few npm scripts to get a working api endpoint.
The clear downside is that since this is not the same as the production api, there is a potential for bugs if the endpoint changes.
In general, I try to avoid premature optimization and this is a clear problem while the api changes are less pressing.
Besides, if the api changes, I just need to update the db.json to reflect the new data structure and I can keep on trucking.</p>

<p>Other benefits to this approach include speed (less latency) and not having to worry about api limits (less of an issue for this particular project, but still worth considering).</p>

<p>I may not be fully bought into Webpack just yet, but this certainly helps.</p>

                </section>
            </article>

            

            

            

            <footer id="footer">
    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> 
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="http://thejoemorgan.comjs/jquery-3.3.1.min.js"></script>
<script src="http://thejoemorgan.comjs/main.js"></script>
<script src="http://thejoemorgan.comjs/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
